import psycopg2
import psycopg2.extras
import os
import sys
import logging
import json
import copy
import datetime
import uuid

from pathlib import Path

from decimal import Decimal
from uuid import UUID
from typing import Tuple

logger = logging.getLogger()
logger.setLevel(logging.INFO)


# ------------------------------------------------------------------------ Logging ------------------------------------------------------------------------


def log_to_lambda_error_log(
    calling_status_code, status_message, erroring_lambda, required_keys
):
    """
    Logs caught error conditions to the lambda_errors
    """
    status_code = 200
    results = "ok"
    query_type = "simple_write"
    parameters = [
        str(uuid.uuid4()),
        str(erroring_lambda),
        str(calling_status_code),
        str(status_message),
        str(required_keys),
    ]

    query_statement = "insert into lambda_errors (event_date, error_id, erroring_lambda, status_code, status_message, resolved, api_call "
    values_statement = "values (now(), %s, %s, %s, %s, false, %s"
    if "store_id" in required_keys and required_keys["store_id"] != "":
        parameters.append(required_keys["store_id"])
        query_statement += ", store_id"
        values_statement += ", %s"
    if "api_key" in required_keys and required_keys["api_key"] != "":
        parameters.append(required_keys["api_key"])
        query_statement += ", api_key"
        values_statement += ", %s"
    if "app_key" in required_keys and required_keys["app_key"] != "":
        parameters.append(required_keys["app_key"])
        query_statement += ", app_key"
        values_statement += ", %s"
    query_statement += ") "
    values_statement += ")"
    query_statement += values_statement

    status_code, results = execute_query(query_statement, parameters, query_type)
    if status_code != 200:
        logger.warning(
            f"log_to_lambda_error_log exiting with status_code {status_code}"
        )
    return (status_code, results)


def errlog(error_number, error_family, error_module, error_message):
    """
    Creates consistent error messages
    usage- error number (status code), error message (literal custom error string to pass to the log),
    error family (type of error), error module (module the error occured in), then API parameters used
    """
    logger.error(
        "-------------------------- BEGIN ERROR BLOCK --------------------------"
    )
    logger.error(
        f"Error Of Type {error_family} Error Number {error_number} In Module {error_module}"
    )
    logger.error(f"Error Message: {error_message}")
    logger.error(
        "--------------------------- END ERROR BLOCK ---------------------------"
    )


def status_log(status_code):
    """If status_code != 200, logs the status_code for end user troubleshooting"""
    calling_module_list = []

    if status_code != 200 and status_code != 201:
        calling_module_temp = str(sys._getframe(1))
        calling_module_list = calling_module_temp.split()
        last_item_index = len(calling_module_list)
        calling_module = calling_module_list[last_item_index - 1]
        calling_module = calling_module.replace(">", "")
        logger.warning(f"{calling_module} exiting with status_code {status_code}")
    return ()


def json_convert_dates(json_element):
    """Allows json.loads to deal with date and datetime elements"""
    if isinstance(json_element, datetime.datetime):
        return json_element.__str__()
    elif isinstance(json_element, datetime.date):
        return json_element.__str__()
    elif isinstance(json_element, Decimal):
        return json_element.__float__()
    return json_element


# ------------------------------------------------------------------------ Database ------------------------------------------------------------------------
def convert_db_inputs_to_list(
    query_statement,
    parameters,
    call_type,
):
    """
    Ensures all supplied inputs to the DB are in a list form and that the lists contain the same number of elements.
    """
    status_code = 200
    results = "ok"
    query_list = []
    parameter_list = []
    call_type_list = []

    try:  # Ensure that the supplied inputs are a list, even if they are a list of one
        if not isinstance(query_statement, list):
            query_list.append(query_statement)
        else:
            query_list = query_statement

        if not isinstance(call_type, list):
            call_type_list.append(call_type)
        else:
            call_type_list = call_type

        if len(parameters) == 0:
            parameter_list.append(parameters)
        else:
            if len(parameters) > 0 and not isinstance(
                parameters[0], list
            ):  # Since parameters is a list anyway, we have to check the first element
                parameter_list.append(parameters)
            else:
                parameter_list = tuple(parameters)

        if len(parameter_list) == len(query_list) == len(call_type_list):
            # Make sure the lists have the same number of elements or the queries will break
            status_code = 200
        else:
            status_code = 400
            results = (
                "Fatal error- supplied values do not have the same number of parameters"
            )
            results += "\nNumber of supplied query statments: " + str(len(query_list))
            results += "\nNumber of supplied parameter sets: " + str(
                len(parameter_list)
            )
            results += "\nNumber of supplied call types: " + str(len(call_type_list))
            logger.error(results)
    except:
        status_code = 400
        logger.error(sys.exc_info())
        results = "Fatal error with DB query parameters conversion"

    if status_code == 200:
        results = {
            "query_list": query_list,
            "parameter_list": parameter_list,
            "call_type_list": call_type_list,
        }

    status_log(status_code)
    return (status_code, results)


def execute_query(
    query_statement,
    parameters,
    call_type,
):
    """
    Connects to DB and performs provided query, returns status code and any results.
    Query_type (string or list of strings) is the actual query statement(s) to run
    Parameters (list or list of lists) are the parameters for a query statement
    Call_type (string or list of strings) is used for different scenarios
    Output type (string or list of strings) is used to denote if the output is list of dicts or lists
    Note that if a query in a list of queries errors, none of the transactions will be committed.
    """
    return_results = []
    query_list = []
    parameter_list = []
    call_type_list = []

    status_code = 200
    cur = ""

    status_code, results = convert_db_inputs_to_list(
        query_statement,
        parameters,
        call_type,
    )
    if status_code == 200:
        query_list = results["query_list"]
        parameter_list = results["parameter_list"]
        call_type_list = results["call_type_list"]

    conn = psycopg2.connect(  # Database Connection Block
        host=os.environ["DB_HOST"],
        database=os.environ["DB_DATABASE"],
        user=os.environ["DB_USERNAME"],
        password=os.environ["DB_PASSWORD"],
    )

    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    """ 
    There isn't a good way to mix and match outputs based on the cursor (list vs Dict) without resetting
    the connection between DB calls, which will be very inefficient. So when output type is list of lists
    we will need to parse the output as a dict and then convert back to a string of values.
    """
    try:
        i = 0
        while len(query_list) > i and status_code == 200:
            query = query_list[i]
            params = tuple(parameter_list[i])
            call = call_type_list[i]

            if call == "simple_write":  # simple insert
                cur.execute(query, params)
                rowcount = f"Rows updated {cur.rowcount}"
                results = {"results": rowcount}
            elif call == "complex_write":  # inserts using as_string method
                cur.execute(query.as_string(conn), params)
                rowcount = f"Rows updated {cur.rowcount}"
                results = {"results": rowcount}
            elif call == "return_all":  # Returns all results
                results = []
                cur.execute(query, params)
                for record in cur:
                    results.append(dict(record))

            if status_code == 200:
                results = json.loads(json.dumps(results, default=json_convert_dates))
                return_results.append(results)
            else:
                return_results = results
            i += 1

        if status_code == 200:  # Commit the transactions
            conn.commit()
        else:
            return_results = results
            return_results += f"\n in transaction {i} for query ({query})"

    except (Exception, psycopg2.DatabaseError) as error:  # Some database error
        status_code = 500
        return_results = str(error)
        logger.error(sys.exc_info())
        logger.error(return_results)
        logger.error(f"\n for query ({query}) with parameters {params}")
        logger.error(f"{return_results}")

    finally:
        cur.close()
        conn.close()

    status_log(status_code)
    return (status_code, return_results)


# ------------------------------------------------------------------------ Key Checks and Validation ------------------------------------------------------------------


def filter_results(unfiltered_results, mask):
    """Use with mask list to reduce the data being returned to the client."""
    status_code = 200
    results = "ok"
    filtered_results_list = []

    try:
        for records in unfiltered_results:
            filtered_dict = {}
            for each in mask:
                if each in records:
                    filtered_dict[each] = records[each]
                else:
                    filtered_dict[each] = None  # Set null value if key doesn't exist.
            filtered_results_list.append(copy.deepcopy(filtered_dict))
    except:
        status_code = 400
        logger.error(sys.exc_info())
        results = "fatal error building filtered dict list"

    if status_code == 200:
        results = filtered_results_list

    status_log(status_code)
    return (status_code, results)


def check_key(key: any, max_length: int) -> Tuple[int, str]:
    """
    Checks a value to ensure it meets key requirements for length and content.
    Used to sanitize event keys from lambda invocation.
    """
    status_code = 200
    results = "ok"

    if len(key) > max_length:
        status_code = 413  # Key too long
        results = "Key too long"
    elif ";" in key:  # Bobby tables
        status_code = 405  # Invalid character in key
        results = "Someone is trying to pull a bobby tables"
    elif "\\" in key:  # someone trying to escape something
        status_code = 405  # Invalid character in key
        results = "Backslash in key"
    status_log(status_code)

    return (status_code, results)


def is_valid_uuid(uuid_to_test: str) -> bool:
    """Tests if a value can be converted to UUID4."""
    try:
        UUID(uuid_to_test, version=4)
    except:
        logger.error(sys.exc_info())
        return False
    return True


def validate_api_token_id(api_key: str, store_id: str) -> int:
    """Validates API token ID is current and valid for store"""
    parameters = [api_key, store_id]
    query_type = "logon_verification"

    query_statement = "select auth_app_table.store_id from auth_api_table "
    query_statement += "inner join auth_app_table "
    query_statement += "on auth_api_table.app_id = auth_app_table.app_id "
    query_statement += "where "
    query_statement += "auth_api_table.vendor_api_token = %s "
    query_statement += "and auth_app_table.store_id = %s "
    query_statement += "and auth_app_table.expiration_date > now() "

    status_code, results = execute_query(query_statement, parameters, query_type)

    status_log(status_code)

    return (status_code, results)


def get_app_id(api_key):
    """Pulls app id from auth_api_table"""
    parameters = [
        api_key,
    ]
    query_type = "return_one"
    app_id = ""

    query_statement = "select app_id from auth_api_table where vendor_api_token = %s"
    status_code, results = execute_query(query_statement, parameters, query_type)

    if status_code != 200:
        app_id = "error"
    else:
        app_id = results["app_id"]

    status_log(status_code)
    return (status_code, app_id)


def string_cleaner(input_string: str) -> str:
    """
    Removes garbage charactes from a string
    Mostly used to help with json conversion from dictionaries
    input:
        input_string: string
    output
        output_string: string
    """
    input_string = input_string.replace("'", '"')
    input_string = input_string.replace('"{', "{")
    input_string = input_string.replace('"[{', "[{")
    input_string = input_string.replace('}]"', "}]")
    input_string = input_string.replace("False", "false")
    input_string = input_string.replace("True", "true")
    input_string = input_string.replace("None", "null")
    input_string = input_string.replace("\\", "")
    output_string = input_string.replace('}"', "}")

    return output_string


def read_sql_query_from_path(sql_path: Path) -> str:
    """Read SQL file as string."""
    return Path(sql_path).read_text()
